---
layout: posts
title:  "Modern Application Development: Should you skip microservices and go directly to serverless?"
date:   2018-01-19 10:16:01 -0600
categories: jekyll update
---

You don’t have to look further than the Gartner Hype Cycle to see the staggering pace of innovation in application architecture. Microservices, reactive programming, and container management are among the architectural models at the peak of the Cycle, making deep scrutiny a must as you consider the systems, processes, and tool choices for modern application development. And while it’s not entirely unheard of to skip a generation of technology and jump headfirst into the latest shiny object, doing so often comes with significant risk. It’s not quite the same as a strong advancement in the game of Monopoly. So if you’re wondering if you should skip microservices and go directly to serverless, here’s some food for thought.
Recently,function-as-as-service (FaaS) and serverless technologies like AWS Lambda have captured our imaginations with the promise to run idempotent units of functionality at scale on someone else’s infrastructure. In some ways, it represents one of the largest technology unicorns in the land.

It’s not all rainbows and butterflies
Serverless architectures leverage the elastic compute capacity of an underlying infrastructure to provide ephemeral and idempotent functions (e.g. file handling, data transformation, system integration, single-sign-on, etc.) that can be invoked directly by business applications. These services/functions are considered an easy method to implement ‘pay-as-you-go’ event-driven, stateless microservices. Further, serverless architectures promote the ability to reduce many core IT responsibilities such as patching and maintaining servers, networking, scaling of services, etc. Problems can arise however, when trying to understand the appropriate service to use for a given problem; architectural governance and standards are now more dependant on partner relationships and not in the firm control of the service consumer or enterprise IT.

A quick history lesson
Serverless and FaaS has its foundation in functional programming. Recall, functional programming originates from concepts developed in the 1930s with Lambda Calculus. It’s rooted in function definition, function abstraction and the usage of variables for function application. We didn’t see much from functional programming until the 1960s, when Common Lisp became the first functional programming language. Since then, functional programming evolved and many popular languages of today have support for functional programming concepts including JavaScript, Python, C# and even Java.
When considering the idempotent and stateless nature of functions, you can see why functional programming has strong relevance to microservice-based cloud-native application development. Taking it a step further, a cloud-native application can easily leverage a function call to a FaaS or serverless environment to perform a number of activities, such as processing a customer login event, computing an analytic, or evaluating a decision. And it can do it all while never having to be concerned with the underlying function scale, security, maintenance or performance (kinda cool). Having said that, there is some level of lock-in with Google Cloud functions, Microsoft Azure Functions, Amazon Lambda, Oracle Functions, VMWare Functions, etc. due to their pervasive coupling on underlying and supporting dependant services. This coupling and chaining of services at scale must be considered as part of an enterprise serverless strategy and governance model to ensure application portability and overall cost of ownership.

The hidden costs of serverless architectures
While many of the core technologies and architecture styles that support cloud-native development are readily available today, adopting them wholesale may come with a significant cost. Serverless architectures come with hard and soft costs that may not be immediately obvious. Hard costs may include added network latency and difficulty in troubleshooting a business transaction through a distributed service mesh. Soft costs include the technical team competency needed for managing high levels of complexity, as well as the overall application and service portability (cost of migration from one serverless platform/vendor to another).

Providing guardrails, not gates
Red Hat understands the serverless and FaaS landscape as a forest of promise not without its hidden monsters. That said, we are working with communities to implement new technologies that provide guardrails and not gates. We want enterprise development teams to have the freedom to innovate at full speed but without compromising on built-in, enterprise-required controls such as security, stability and governance. An example of this approach is with Red Hat OpenShift Application Runtimes (RHOAR), which is a collection of application development runtimes and languages that support cloud-native, microservice-based development and includes a path to serverless architectures. RHOAR, along with the OpenShift Container Management Platform, will in time include core technologies that enable serverless architectures for private, hybrid and multi-cloud deployments. Leveraging the Red Hat approach to serverless architectures allows an enterprise to fully own, manage and govern their services at scale and across cloud providers to quickly build, run and maintain cloud-native applications.

While skipping an evolution to microservices and jumping right to the unicorn-serverless-world may sound appealing, the approach doesn’t come without significant risk. As with all evolution, incremental steps of improvement that are well understood and illustrate environmental adaptations are the most successful and sustainable. That said, moving from big monoliths to fast-moving monoliths, from microservices to serverless is, perhaps, the most successful approach that enterprise IT teams should adopt. It’s a better than keeping your fingers crossed that you’ll roll the dice, pass GO and collect $200.
